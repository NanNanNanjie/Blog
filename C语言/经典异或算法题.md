## 经典异或算法题（7.20）
### 题目描述：
给定一个数组，其中只有一个数字是出现一次，其他数字都是出现两次，请你编写一个程序，找出那个只出现一次的数字。
### 测试用例
输入：[1, 2, 3, 2, 1]
输出：3

### 解题思路
第一眼看到这道题，可能很多人摸不到头脑，其实这是一道比较经典的算法题，方法比较巧妙，我们可以利用异或的思想来解决。
在做这道题之前，如果你对异或的性质不是很了解，请你善用搜索引擎，了解一下有关异或的定义以及基本运算，在这里我列举一些有关这道题的性质：
1. a ^ a = 0 (自己和自己异或结果得0)
2. a ^ 0 = a (某个数跟0异或还是它本身)

在我们知道以上两个性质之后，我们就可以利用异或的思想来解决，遍历整个数组，将他们都异或在一起，因为某个数跟他本身异或等于0，所以出现两次的数异或之后都是0，最终的结果就是我们要找的那个数。
### 代码实现
```c
#include <stdio.h>
const int N = 1e5;

int main()
{
	int n;
	scanf("%d", &n);
	int a[N];
	for (int i = 0; i < n; i ++) scanf("%d", a[i]);
	
	int res = 0;
	for (int i = 0; i < n; i ++) {
		res ^= i; // 和每个数分别异或
	}
	printf("%d", res);  // res就是我们就要找的那个数
}
```
如果，我们将问题深入一些，将出现一次的数字从1变成2，又该如何思考呢？

### 解题思路
其实还是利用异或的思想，只不过这次，我们通过遍历整个数组进行异或的方法，得不到两个数，只能得到他们进行异或之后的结果，那么应该如何获得两个数呢？

我们先举一个例子，如果该数组为[1, 2, 3, 4, 5, 1, 2, 3, 4, 6]，不难看出，只出现一次的数字分别为5 和 6，我们观察可得 5(101) ^ 6(110) = 3(011)。

我们知道，两个二进制位相同，异或结果为0，相异，异或结果为1，那么，我们就可以得出，如果某位异或之后的结果为1，那么它们所对应的二进制为一定是不同的，我们可以根据这个思想，将该数组分为两部分，一部分是某个二进制位为1的，另一部分是某个二进制位为0的。

那么，如果找到这一位呢？其实很简单，比如3的二进制表示为011，我们可以找其中为1的位，根据这一位来进行分组，因为1代表着相异，从而把两个只出现一次的数字给找出来。

### 代码实现
```c
#Include <stdio.h>

int main()
{
    int arr[100] = { 0 };
    int size = 0;
    int num1 = 0;
    int num2 = 0;
    scanf("%d", &size);
    for (int i = 0; i < size; i++) {
        scanf("%d", &arr[i]);
    }

    int ret = 0;
    for (int i = 0; i < size; i++) {
        ret ^= arr[i]; // 异或计算数组元素的结果
    }

    int p = 0; // 按照哪位进行分组
    for (int i = 0; i < 32; i++) {
        if ((ret >> i) & 1 == 1) {
            // 第i位为1
            p = i;
        }
    }

    // 对数组中的元素进行分组
    for (int i = 0; i < size; i++) {
        if ((arr[i] >> p) & 1 == 1) {
            num1 ^= arr[i];
        }
        else {
            num2 ^= arr[i];
        }
    }

    printf("%d %d", num1, num2);

    return 0;
}
```
好了，今天的算法题就分享到这里，希望大家对异或的定义以及性质能有一个更深的了解，喜欢本期内容的可以为博主点上一波关注，谢谢各位。